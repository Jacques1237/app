{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, switchMap, tap } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { observeOutsideAngular, keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Pipe, NgModule } from '@angular/core';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/storage';\nimport * as i2 from '@angular/fire/app-check';\nimport { AsyncPipe } from '@angular/common';\nimport * as i2$1 from '@angular/platform-browser';\nimport { makeStateKey } from '@angular/platform-browser';\nimport firebase from 'firebase/compat/app'; // Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\n\nfunction fromTask(task) {\n  return new Observable(function (subscriber) {\n    var progress = function progress(snap) {\n      return subscriber.next(snap);\n    };\n\n    var error = function error(e) {\n      return subscriber.error(e);\n    };\n\n    var complete = function complete() {\n      return subscriber.complete();\n    }; // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n\n\n    progress(task.snapshot);\n    var unsub = task.on('state_changed', progress); // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n\n    task.then(function (snapshot) {\n      progress(snapshot);\n      complete();\n    }, function (e) {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    }); // on's type if Function, rather than () => void, need to wrap\n\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe( // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\n\n\nfunction createUploadTask(task) {\n  var inner$ = fromTask(task);\n  return {\n    task: task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: function snapshotChanges() {\n      return inner$;\n    },\n    percentageChanges: function percentageChanges() {\n      return inner$.pipe(map(function (s) {\n        return s.bytesTransferred / s.totalBytes * 100;\n      }));\n    }\n  };\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\n\n\nfunction createStorageRef(ref) {\n  return {\n    getDownloadURL: function getDownloadURL() {\n      return of(undefined).pipe(observeOutsideAngular, switchMap(function () {\n        return ref.getDownloadURL();\n      }), keepUnstableUntilFirst);\n    },\n    getMetadata: function getMetadata() {\n      return of(undefined).pipe(observeOutsideAngular, switchMap(function () {\n        return ref.getMetadata();\n      }), keepUnstableUntilFirst);\n    },\n    delete: function _delete() {\n      return from(ref.delete());\n    },\n    child: function child(path) {\n      return createStorageRef(ref.child(path));\n    },\n    updateMetadata: function updateMetadata(meta) {\n      return from(ref.updateMetadata(meta));\n    },\n    put: function put(data, metadata) {\n      var task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: function putString(data, format, metadata) {\n      var task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    list: function list(options) {\n      return from(ref.list(options));\n    },\n    listAll: function listAll() {\n      return from(ref.listAll());\n    }\n  };\n}\n\nvar BUCKET = /*#__PURE__*/new InjectionToken('angularfire2.storageBucket');\nvar MAX_UPLOAD_RETRY_TIME = /*#__PURE__*/new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nvar MAX_OPERATION_RETRY_TIME = /*#__PURE__*/new InjectionToken('angularfire2.storage.maxOperationRetryTime');\nvar USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.storage.use-emulator');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n\nvar AngularFireStorage = /*#__PURE__*/(function () {\n  var AngularFireStorage = /*#__PURE__*/function () {\n    function AngularFireStorage(options, name, storageBucket, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, maxUploadRetryTime, maxOperationRetryTime, _useEmulator, _appCheckInstances) {\n      _classCallCheck(this, AngularFireStorage);\n\n      var app = ɵfirebaseAppFactory(options, zone, name);\n      this.storage = ɵcacheInstance(\"\".concat(app.name, \".storage.\").concat(storageBucket), 'AngularFireStorage', app.name, function () {\n        var storage = zone.runOutsideAngular(function () {\n          return app.storage(storageBucket || undefined);\n        });\n        var useEmulator = _useEmulator;\n\n        if (useEmulator) {\n          storage.useEmulator.apply(storage, _toConsumableArray(useEmulator));\n        }\n\n        if (maxUploadRetryTime) {\n          storage.setMaxUploadRetryTime(maxUploadRetryTime);\n        }\n\n        if (maxOperationRetryTime) {\n          storage.setMaxOperationRetryTime(maxOperationRetryTime);\n        }\n\n        return storage;\n      }, [maxUploadRetryTime, maxOperationRetryTime]);\n    }\n\n    _createClass(AngularFireStorage, [{\n      key: \"ref\",\n      value: function ref(path) {\n        return createStorageRef(this.storage.ref(path));\n      }\n    }, {\n      key: \"refFromURL\",\n      value: function refFromURL(path) {\n        return createStorageRef(this.storage.refFromURL(path));\n      }\n    }, {\n      key: \"upload\",\n      value: function upload(path, data, metadata) {\n        var storageRef = this.storage.ref(path);\n        var ref = createStorageRef(storageRef);\n        return ref.put(data, metadata);\n      }\n    }]);\n\n    return AngularFireStorage;\n  }();\n\n  AngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n    return new (t || AngularFireStorage)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(BUCKET, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), i0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n  };\n\n  AngularFireStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireStorage,\n    factory: AngularFireStorage.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireStorage;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** to be used with in combination with | async */\n\n\nvar GetDownloadURLPipe = /*#__PURE__*/(function () {\n  var GetDownloadURLPipe = /*#__PURE__*/function () {\n    function GetDownloadURLPipe(storage, cdr, state) {\n      _classCallCheck(this, GetDownloadURLPipe);\n\n      this.storage = storage;\n      this.state = state;\n      this.asyncPipe = new AsyncPipe(cdr);\n    }\n\n    _createClass(GetDownloadURLPipe, [{\n      key: \"transform\",\n      value: function transform(path) {\n        var _this = this;\n\n        var _a;\n\n        if (path !== this.path) {\n          this.path = path;\n          var key = makeStateKey(\"|getDownloadURL|\".concat(path));\n          var existing = (_a = this.state) === null || _a === void 0 ? void 0 : _a.get(key, undefined);\n          this.downloadUrl$ = existing ? of(existing) : this.storage.ref(path).getDownloadURL().pipe(tap(function (it) {\n            var _a;\n\n            return (_a = _this.state) === null || _a === void 0 ? void 0 : _a.set(key, it);\n          }));\n        }\n\n        return this.asyncPipe.transform(this.downloadUrl$);\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.asyncPipe.ngOnDestroy();\n      }\n    }]);\n\n    return GetDownloadURLPipe;\n  }();\n\n  GetDownloadURLPipe.ɵfac = function GetDownloadURLPipe_Factory(t) {\n    return new (t || GetDownloadURLPipe)(i0.ɵɵdirectiveInject(AngularFireStorage, 16), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16), i0.ɵɵdirectiveInject(i2$1.TransferState, 24));\n  };\n\n  GetDownloadURLPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"getDownloadURL\",\n    type: GetDownloadURLPipe,\n    pure: false\n  });\n  return GetDownloadURLPipe;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar GetDownloadURLPipeModule = /*#__PURE__*/(function () {\n  var GetDownloadURLPipeModule = function GetDownloadURLPipeModule() {\n    _classCallCheck(this, GetDownloadURLPipeModule);\n  };\n\n  GetDownloadURLPipeModule.ɵfac = function GetDownloadURLPipeModule_Factory(t) {\n    return new (t || GetDownloadURLPipeModule)();\n  };\n\n  GetDownloadURLPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GetDownloadURLPipeModule\n  });\n  GetDownloadURLPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return GetDownloadURLPipeModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar AngularFireStorageModule = /*#__PURE__*/(function () {\n  var AngularFireStorageModule = function AngularFireStorageModule() {\n    _classCallCheck(this, AngularFireStorageModule);\n\n    firebase.registerVersion('angularfire', VERSION.full, 'gcs-compat');\n  };\n\n  AngularFireStorageModule.ɵfac = function AngularFireStorageModule_Factory(t) {\n    return new (t || AngularFireStorageModule)();\n  };\n\n  AngularFireStorageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireStorageModule\n  });\n  AngularFireStorageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireStorage],\n    imports: [GetDownloadURLPipeModule]\n  });\n  return AngularFireStorageModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask }; //# sourceMappingURL=angular-fire-compat-storage.js.map","map":null,"metadata":{},"sourceType":"module"}