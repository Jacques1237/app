{"ast":null,"code":"import _slicedToArray from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/wwwja/Desktop/Gallery-master/app/Gallery/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar transitionEnd = function transitionEnd(el, callback) {\n  var unRegTrans;\n  var opts = {\n    passive: true\n  };\n\n  var unregister = function unregister() {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n\n  var onTransitionEnd = function onTransitionEnd(ev) {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n\n    unRegTrans = function unRegTrans() {\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n\n  return unregister;\n};\n\nvar CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\nvar DURATION_MIN = 32;\nvar TRANSITION_END_FALLBACK_PADDING_MS = 400;\nvar TRANSFORM_PROPS = {\n  'translateX': 1,\n  'translateY': 1,\n  'translateZ': 1,\n  'scale': 1,\n  'scaleX': 1,\n  'scaleY': 1,\n  'scaleZ': 1,\n  'rotate': 1,\n  'rotateX': 1,\n  'rotateY': 1,\n  'rotateZ': 1,\n  'skewX': 1,\n  'skewY': 1,\n  'perspective': 1\n};\nvar win = typeof window !== 'undefined' ? window : {};\nvar raf = win.requestAnimationFrame ? win.requestAnimationFrame.bind(win) : function (f) {\n  return f(Date.now());\n};\n\nvar Animator = /*#__PURE__*/function () {\n  function Animator() {\n    _classCallCheck(this, Animator);\n\n    this._hasDur = false;\n    this._hasTweenEffect = false;\n    this._isAsync = false;\n    this._isReverse = false;\n    this._destroyed = false;\n    this.hasChildren = false;\n    this.isPlaying = false;\n    this.hasCompleted = false;\n  }\n\n  _createClass(Animator, [{\n    key: \"addElement\",\n    value: function addElement(el) {\n      if (el != null) {\n        if (el.length > 0) {\n          for (var i = 0; i < el.length; i++) {\n            this._addEl(el[i]);\n          }\n        } else {\n          this._addEl(el);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * NO DOM\r\n     */\n\n  }, {\n    key: \"_addEl\",\n    value: function _addEl(el) {\n      if (el.nodeType === 1) {\n        (this._elements = this._elements || []).push(el);\n      }\n    }\n    /**\r\n     * Add a child animation to this animation.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(childAnimation) {\n      childAnimation.parent = this;\n      this.hasChildren = true;\n      (this._childAnimations = this._childAnimations || []).push(childAnimation);\n      return this;\n    }\n    /**\r\n     * Get the duration of this animation. If this animation does\r\n     * not have a duration, then it'll get the duration from its parent.\r\n     */\n\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(opts) {\n      if (opts && opts.duration !== undefined) {\n        return opts.duration;\n      } else if (this._duration !== undefined) {\n        return this._duration;\n      } else if (this.parent) {\n        return this.parent.getDuration();\n      }\n\n      return 0;\n    }\n    /**\r\n     * Returns if the animation is a root one.\r\n     */\n\n  }, {\n    key: \"isRoot\",\n    value: function isRoot() {\n      return !this.parent;\n    }\n    /**\r\n     * Set the duration for this animation.\r\n     */\n\n  }, {\n    key: \"duration\",\n    value: function duration(milliseconds) {\n      this._duration = milliseconds;\n      return this;\n    }\n    /**\r\n     * Get the easing of this animation. If this animation does\r\n     * not have an easing, then it'll get the easing from its parent.\r\n     */\n\n  }, {\n    key: \"getEasing\",\n    value: function getEasing() {\n      if (this._isReverse && this._reversedEasingName !== undefined) {\n        return this._reversedEasingName;\n      }\n\n      return this._easingName !== undefined ? this._easingName : this.parent && this.parent.getEasing() || null;\n    }\n    /**\r\n     * Set the easing for this animation.\r\n     */\n\n  }, {\n    key: \"easing\",\n    value: function easing(name) {\n      this._easingName = name;\n      return this;\n    }\n    /**\r\n     * Set the easing for this reversed animation.\r\n     */\n\n  }, {\n    key: \"easingReverse\",\n    value: function easingReverse(name) {\n      this._reversedEasingName = name;\n      return this;\n    }\n    /**\r\n     * Add the \"from\" value for a specific property.\r\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(prop, val) {\n      this._addProp('from', prop, val);\n\n      return this;\n    }\n    /**\r\n     * Add the \"to\" value for a specific property.\r\n     */\n\n  }, {\n    key: \"to\",\n    value: function to(prop, val) {\n      var clearProperyAfterTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var fx = this._addProp('to', prop, val);\n\n      if (clearProperyAfterTransition) {\n        // if this effect is a transform then clear the transform effect\n        // otherwise just clear the actual property\n        this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\n      }\n\n      return this;\n    }\n    /**\r\n     * Shortcut to add both the \"from\" and \"to\" for the same property.\r\n     */\n\n  }, {\n    key: \"fromTo\",\n    value: function fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\n      return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\n    }\n    /**\r\n     * NO DOM\r\n     */\n\n  }, {\n    key: \"_getProp\",\n    value: function _getProp(name) {\n      if (this._fxProperties) {\n        return this._fxProperties.find(function (prop) {\n          return prop.effectName === name;\n        });\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"_addProp\",\n    value: function _addProp(state, prop, val) {\n      var fxProp = this._getProp(prop);\n\n      if (!fxProp) {\n        // first time we've see this EffectProperty\n        var shouldTrans = TRANSFORM_PROPS[prop] === 1;\n        fxProp = {\n          effectName: prop,\n          trans: shouldTrans,\n          // add the will-change property for transforms or opacity\n          wc: shouldTrans ? 'transform' : prop\n        };\n        (this._fxProperties = this._fxProperties || []).push(fxProp);\n      } // add from/to EffectState to the EffectProperty\n\n\n      var fxState = {\n        val: val,\n        num: 0,\n        effectUnit: ''\n      };\n      fxProp[state] = fxState;\n\n      if (typeof val === 'string' && val.indexOf(' ') < 0) {\n        var r = val.match(CSS_VALUE_REGEX);\n\n        if (r) {\n          var num = parseFloat(r[1]);\n\n          if (!isNaN(num)) {\n            fxState.num = num;\n          }\n\n          fxState.effectUnit = r[0] !== r[2] ? r[2] : '';\n        }\n      } else if (typeof val === 'number') {\n        fxState.num = val;\n      }\n\n      return fxProp;\n    }\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeAddClass\",\n    value: function beforeAddClass(className) {\n      (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\n      return this;\n    }\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeRemoveClass\",\n    value: function beforeRemoveClass(className) {\n      (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\n      return this;\n    }\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeStyles\",\n    value: function beforeStyles(styles) {\n      this._beforeStyles = styles;\n      return this;\n    }\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeClearStyles\",\n    value: function beforeClearStyles(propertyNames) {\n      this._beforeStyles = this._beforeStyles || {};\n\n      var _iterator = _createForOfIteratorHelper(propertyNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          this._beforeStyles[prop] = '';\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this;\n    }\n    /**\r\n     * Add a function which contains DOM reads, which will run\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeAddRead\",\n    value: function beforeAddRead(domReadFn) {\n      (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\n      return this;\n    }\n    /**\r\n     * Add a function which contains DOM writes, which will run\r\n     * before the animation begins.\r\n     */\n\n  }, {\n    key: \"beforeAddWrite\",\n    value: function beforeAddWrite(domWriteFn) {\n      (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\n      return this;\n    }\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * after the animation finishes.\r\n     */\n\n  }, {\n    key: \"afterAddClass\",\n    value: function afterAddClass(className) {\n      (this._afterAddClasses = this._afterAddClasses || []).push(className);\n      return this;\n    }\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * after the animation finishes.\r\n     */\n\n  }, {\n    key: \"afterRemoveClass\",\n    value: function afterRemoveClass(className) {\n      (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\n      return this;\n    }\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * after the animation finishes.\r\n     */\n\n  }, {\n    key: \"afterStyles\",\n    value: function afterStyles(styles) {\n      this._afterStyles = styles;\n      return this;\n    }\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * after the animation finishes.\r\n     */\n\n  }, {\n    key: \"afterClearStyles\",\n    value: function afterClearStyles(propertyNames) {\n      this._afterStyles = this._afterStyles || {};\n\n      var _iterator2 = _createForOfIteratorHelper(propertyNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var prop = _step2.value;\n          this._afterStyles[prop] = '';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this;\n    }\n    /**\r\n     * Play the animation.\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play(opts) {\n      var _this = this;\n\n      // If the animation was already invalidated (it did finish), do nothing\n      if (this._destroyed) {\n        return;\n      } // this is the top level animation and is in full control\n      // of when the async play() should actually kick off\n      // if there is no duration then it'll set the TO property immediately\n      // if there is a duration, then it'll stage all animations at the\n      // FROM property and transition duration, wait a few frames, then\n      // kick off the animation by setting the TO property for each animation\n\n\n      this._isAsync = this._hasDuration(opts); // ensure all past transition end events have been cleared\n\n      this._clearAsync(); // recursively kicks off the correct progress step for each child animation\n      // ******** DOM WRITE ****************\n\n\n      this._playInit(opts); // doubling up RAFs since this animation was probably triggered\n      // from an input event, and just having one RAF would have this code\n      // run within the same frame as the triggering input event, and the\n      // input event probably already did way too much work for one frame\n\n\n      raf(function () {\n        raf(function () {\n          _this._playDomInspect(opts);\n        });\n      });\n    }\n  }, {\n    key: \"playAsync\",\n    value: function playAsync(opts) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.onFinish(resolve, {\n          oneTimeCallback: true,\n          clearExistingCallbacks: true\n        });\n\n        _this2.play(opts);\n\n        return _this2;\n      });\n    }\n  }, {\n    key: \"playSync\",\n    value: function playSync() {\n      // If the animation was already invalidated (it did finish), do nothing\n      if (!this._destroyed) {\n        var opts = {\n          duration: 0\n        };\n        this._isAsync = false;\n\n        this._clearAsync();\n\n        this._playInit(opts);\n\n        this._playDomInspect(opts);\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_playInit\",\n    value: function _playInit(opts) {\n      // always default that an animation does not tween\n      // a tween requires that an Animation class has an element\n      // and that it has at least one FROM/TO effect\n      // and that the FROM/TO effect can tween numeric values\n      this._hasTweenEffect = false;\n      this.isPlaying = true;\n      this.hasCompleted = false;\n      this._hasDur = this.getDuration(opts) > DURATION_MIN;\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator3 = _createForOfIteratorHelper(children),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var child = _step3.value;\n\n            // ******** DOM WRITE ****************\n            child._playInit(opts);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (this._hasDur) {\n        // if there is a duration then we want to start at step 0\n        // ******** DOM WRITE ****************\n        this._progress(0); // add the will-change properties\n        // ******** DOM WRITE ****************\n\n\n        this._willChange(true);\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\n\n  }, {\n    key: \"_playDomInspect\",\n    value: function _playDomInspect(opts) {\n      var _this3 = this;\n\n      // fire off all the \"before\" function that have DOM READS in them\n      // elements will be in the DOM, however visibily hidden\n      // so we can read their dimensions if need be\n      // ******** DOM READ ****************\n      // ******** DOM WRITE ****************\n      this._beforeAnimation(); // for the root animation only\n      // set the async TRANSITION END event\n      // and run onFinishes when the transition ends\n\n\n      var dur = this.getDuration(opts);\n\n      if (this._isAsync) {\n        this._asyncEnd(dur, true);\n      } // ******** DOM WRITE ****************\n\n\n      this._playProgress(opts);\n\n      if (this._isAsync && !this._destroyed) {\n        // this animation has a duration so we need another RAF\n        // for the CSS TRANSITION properties to kick in\n        raf(function () {\n          _this3._playToStep(1);\n        });\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_playProgress\",\n    value: function _playProgress(opts) {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator4 = _createForOfIteratorHelper(children),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var child = _step4.value;\n\n            // ******** DOM WRITE ****************\n            child._playProgress(opts);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      if (this._hasDur) {\n        // set the CSS TRANSITION duration/easing\n        // ******** DOM WRITE ****************\n        this._setTrans(this.getDuration(opts), false);\n      } else {\n        // this animation does not have a duration, so it should not animate\n        // just go straight to the TO properties and call it done\n        // ******** DOM WRITE ****************\n        this._progress(1); // since there was no animation, immediately run the after\n        // ******** DOM WRITE ****************\n\n\n        this._setAfterStyles(); // this animation has no duration, so it has finished\n        // other animations could still be running\n\n\n        this._didFinish(true);\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_playToStep\",\n    value: function _playToStep(stepValue) {\n      if (!this._destroyed) {\n        var children = this._childAnimations;\n\n        if (children) {\n          var _iterator5 = _createForOfIteratorHelper(children),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var child = _step5.value;\n\n              // ******** DOM WRITE ****************\n              child._playToStep(stepValue);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        if (this._hasDur) {\n          // browser had some time to render everything in place\n          // and the transition duration/easing is set\n          // now set the TO properties which will trigger the transition to begin\n          // ******** DOM WRITE ****************\n          this._progress(stepValue);\n        }\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\n\n  }, {\n    key: \"_asyncEnd\",\n    value: function _asyncEnd(dur, shouldComplete) {\n      var self = this;\n\n      var onTransitionEnd = function onTransitionEnd() {\n        // congrats! a successful transition completed!\n        // ensure transition end events and timeouts have been cleared\n        self._clearAsync(); // ******** DOM WRITE ****************\n\n\n        self._playEnd(); // transition finished\n\n\n        self._didFinishAll(shouldComplete, true, false);\n      };\n\n      var onTransitionFallback = function onTransitionFallback() {\n        // oh noz! the transition end event didn't fire in time!\n        // instead the fallback timer when first\n        // if all goes well this fallback should never fire\n        // clear the other async end events from firing\n        self._timerId = undefined;\n\n        self._clearAsync(); // set the after styles\n        // ******** DOM WRITE ****************\n\n\n        self._playEnd(shouldComplete ? 1 : 0); // transition finished\n\n\n        self._didFinishAll(shouldComplete, true, false);\n      }; // set the TRANSITION END event on one of the transition elements\n\n\n      self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd); // set a fallback timeout if the transition end event never fires, or is too slow\n      // transition end fallback: (animation duration + XXms)\n\n      self._timerId = setTimeout(onTransitionFallback, dur + TRANSITION_END_FALLBACK_PADDING_MS);\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_playEnd\",\n    value: function _playEnd(stepValue) {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator6 = _createForOfIteratorHelper(children),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var child = _step6.value;\n\n            // ******** DOM WRITE ****************\n            child._playEnd(stepValue);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n\n      if (this._hasDur) {\n        if (stepValue !== undefined) {\n          // too late to have a smooth animation, just finish it\n          // ******** DOM WRITE ****************\n          this._setTrans(0, true); // ensure the ending progress step gets rendered\n          // ******** DOM WRITE ****************\n\n\n          this._progress(stepValue);\n        } // set the after styles\n        // ******** DOM WRITE ****************\n\n\n        this._setAfterStyles(); // remove the will-change properties\n        // ******** DOM WRITE ****************\n\n\n        this._willChange(false);\n      }\n    }\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_hasDuration\",\n    value: function _hasDuration(opts) {\n      if (this.getDuration(opts) > DURATION_MIN) {\n        return true;\n      }\n\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator7 = _createForOfIteratorHelper(children),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var child = _step7.value;\n\n            if (child._hasDuration(opts)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_hasDomReads\",\n    value: function _hasDomReads() {\n      if (this._readCallbacks && this._readCallbacks.length > 0) {\n        return true;\n      }\n\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator8 = _createForOfIteratorHelper(children),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var child = _step8.value;\n\n            if (child._hasDomReads()) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Immediately stop at the end of the animation.\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var stepValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      // ensure all past transition end events have been cleared\n      this._clearAsync();\n\n      this._hasDur = true;\n\n      this._playEnd(stepValue);\n    }\n    /**\r\n     * NO DOM\r\n     * NO RECURSION\r\n     */\n\n  }, {\n    key: \"_clearAsync\",\n    value: function _clearAsync() {\n      if (this._unregisterTrnsEnd) {\n        this._unregisterTrnsEnd();\n      }\n\n      if (this._timerId) {\n        clearTimeout(this._timerId);\n      }\n\n      this._timerId = this._unregisterTrnsEnd = undefined;\n    }\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\n\n  }, {\n    key: \"_progress\",\n    value: function _progress(stepValue) {\n      // bread 'n butter\n      var val;\n      var elements = this._elements;\n      var effects = this._fxProperties;\n\n      if (!elements || elements.length === 0 || !effects || this._destroyed) {\n        return;\n      } // flip the number if we're going in reverse\n\n\n      if (this._isReverse) {\n        stepValue = 1 - stepValue;\n      }\n\n      var i = 0;\n      var j = 0;\n      var finalTransform = '';\n      var fx;\n\n      for (i = 0; i < effects.length; i++) {\n        fx = effects[i];\n\n        if (fx.from && fx.to) {\n          var fromNum = fx.from.num;\n          var toNum = fx.to.num;\n          var tweenEffect = fromNum !== toNum;\n\n          if (tweenEffect) {\n            this._hasTweenEffect = true;\n          }\n\n          if (stepValue === 0) {\n            // FROM\n            val = fx.from.val;\n          } else if (stepValue === 1) {\n            // TO\n            val = fx.to.val;\n          } else if (tweenEffect) {\n            // EVERYTHING IN BETWEEN\n            var valNum = (toNum - fromNum) * stepValue + fromNum;\n            var unit = fx.to.effectUnit;\n            val = valNum + unit;\n          }\n\n          if (val !== null) {\n            var prop = fx.effectName;\n\n            if (fx.trans) {\n              finalTransform += prop + '(' + val + ') ';\n            } else {\n              for (j = 0; j < elements.length; j++) {\n                // ******** DOM WRITE ****************\n                elements[j].style.setProperty(prop, val);\n              }\n            }\n          }\n        }\n      } // place all transforms on the same property\n\n\n      if (finalTransform.length > 0) {\n        if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\n          finalTransform += 'translateZ(0px)';\n        }\n\n        for (i = 0; i < elements.length; i++) {\n          // ******** DOM WRITE ****************\n          elements[i].style.setProperty('transform', finalTransform);\n          elements[i].style.setProperty('-webkit-transform', finalTransform);\n        }\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\n\n  }, {\n    key: \"_setTrans\",\n    value: function _setTrans(dur, forcedLinearEasing) {\n      // Transition is not enabled if there are not effects\n      var elements = this._elements;\n\n      if (!elements || elements.length === 0 || !this._fxProperties) {\n        return;\n      } // set the TRANSITION properties inline on the element\n\n\n      var easing = forcedLinearEasing ? 'linear' : this.getEasing();\n      var durString = dur + 'ms';\n\n      var _iterator9 = _createForOfIteratorHelper(elements),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var style = _step9.value.style;\n\n          if (dur > 0) {\n            // ******** DOM WRITE ****************\n            style.transitionDuration = durString; // each animation can have a different easing\n\n            if (easing !== null) {\n              // ******** DOM WRITE ****************\n              style.transitionTimingFunction = easing;\n            }\n          } else {\n            style.transitionDuration = '0';\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n    /**\r\n     * DOM READ\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_beforeAnimation\",\n    value: function _beforeAnimation() {\n      // fire off all the \"before\" function that have DOM READS in them\n      // elements will be in the DOM, however visibily hidden\n      // so we can read their dimensions if need be\n      // ******** DOM READ ****************\n      this._fireBeforeReadFunc(); // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\n      // fire off all the \"before\" function that have DOM WRITES in them\n      // ******** DOM WRITE ****************\n\n\n      this._fireBeforeWriteFunc(); // stage all of the before css classes and inline styles\n      // ******** DOM WRITE ****************\n\n\n      this._setBeforeStyles();\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_setBeforeStyles\",\n    value: function _setBeforeStyles() {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator10 = _createForOfIteratorHelper(children),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var child = _step10.value;\n\n            child._setBeforeStyles();\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n\n      var elements = this._elements; // before the animations have started\n      // only set before styles if animation is not reversed\n\n      if (!elements || elements.length === 0 || this._isReverse) {\n        return;\n      }\n\n      var addClasses = this._beforeAddClasses;\n      var removeClasses = this._beforeRemoveClasses;\n\n      var _iterator11 = _createForOfIteratorHelper(elements),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var el = _step11.value;\n          var elementClassList = el.classList; // css classes to add before the animation\n\n          if (addClasses) {\n            var _iterator12 = _createForOfIteratorHelper(addClasses),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var c = _step12.value;\n                // ******** DOM WRITE ****************\n                elementClassList.add(c);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          } // css classes to remove before the animation\n\n\n          if (removeClasses) {\n            var _iterator13 = _createForOfIteratorHelper(removeClasses),\n                _step13;\n\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _c = _step13.value;\n                // ******** DOM WRITE ****************\n                elementClassList.remove(_c);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n          } // inline styles to add before the animation\n\n\n          if (this._beforeStyles) {\n            for (var _i = 0, _Object$entries = Object.entries(this._beforeStyles); _i < _Object$entries.length; _i++) {\n              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                  key = _Object$entries$_i[0],\n                  value = _Object$entries$_i[1];\n\n              // ******** DOM WRITE ****************\n              el.style.setProperty(key, value);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n    /**\r\n     * DOM READ\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_fireBeforeReadFunc\",\n    value: function _fireBeforeReadFunc() {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator14 = _createForOfIteratorHelper(children),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var child = _step14.value;\n\n            // ******** DOM READ ****************\n            child._fireBeforeReadFunc();\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n\n      var readFunctions = this._readCallbacks;\n\n      if (readFunctions) {\n        var _iterator15 = _createForOfIteratorHelper(readFunctions),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var callback = _step15.value;\n            // ******** DOM READ ****************\n            callback();\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_fireBeforeWriteFunc\",\n    value: function _fireBeforeWriteFunc() {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator16 = _createForOfIteratorHelper(children),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var child = _step16.value;\n\n            // ******** DOM WRITE ****************\n            child._fireBeforeWriteFunc();\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n\n      var writeFunctions = this._writeCallbacks;\n\n      if (writeFunctions) {\n        var _iterator17 = _createForOfIteratorHelper(writeFunctions),\n            _step17;\n\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var callback = _step17.value;\n            // ******** DOM WRITE ****************\n            callback();\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     */\n\n  }, {\n    key: \"_setAfterStyles\",\n    value: function _setAfterStyles() {\n      var elements = this._elements;\n\n      if (!elements) {\n        return;\n      }\n\n      var _iterator18 = _createForOfIteratorHelper(elements),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var el = _step18.value;\n          var elementClassList = el.classList; // remove the transition duration/easing\n          // ******** DOM WRITE ****************\n\n          el.style.transitionDuration = el.style.transitionTimingFunction = '';\n\n          if (this._isReverse) {\n            // finished in reverse direction\n            // css classes that were added before the animation should be removed\n            var beforeAddClasses = this._beforeAddClasses;\n\n            if (beforeAddClasses) {\n              var _iterator19 = _createForOfIteratorHelper(beforeAddClasses),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var c = _step19.value;\n                  elementClassList.remove(c);\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            } // css classes that were removed before the animation should be added\n\n\n            var beforeRemoveClasses = this._beforeRemoveClasses;\n\n            if (beforeRemoveClasses) {\n              var _iterator20 = _createForOfIteratorHelper(beforeRemoveClasses),\n                  _step20;\n\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _c2 = _step20.value;\n                  elementClassList.add(_c2);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            } // inline styles that were added before the animation should be removed\n\n\n            var beforeStyles = this._beforeStyles;\n\n            if (beforeStyles) {\n              for (var _i2 = 0, _Object$keys = Object.keys(beforeStyles); _i2 < _Object$keys.length; _i2++) {\n                var propName = _Object$keys[_i2];\n                // ******** DOM WRITE ****************\n                el.style.removeProperty(propName);\n              }\n            }\n          } else {\n            // finished in forward direction\n            // css classes to add after the animation\n            var afterAddClasses = this._afterAddClasses;\n\n            if (afterAddClasses) {\n              var _iterator21 = _createForOfIteratorHelper(afterAddClasses),\n                  _step21;\n\n              try {\n                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                  var _c3 = _step21.value;\n                  // ******** DOM WRITE ****************\n                  elementClassList.add(_c3);\n                }\n              } catch (err) {\n                _iterator21.e(err);\n              } finally {\n                _iterator21.f();\n              }\n            } // css classes to remove after the animation\n\n\n            var afterRemoveClasses = this._afterRemoveClasses;\n\n            if (afterRemoveClasses) {\n              var _iterator22 = _createForOfIteratorHelper(afterRemoveClasses),\n                  _step22;\n\n              try {\n                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                  var _c4 = _step22.value;\n                  // ******** DOM WRITE ****************\n                  elementClassList.remove(_c4);\n                }\n              } catch (err) {\n                _iterator22.e(err);\n              } finally {\n                _iterator22.f();\n              }\n            } // inline styles to add after the animation\n\n\n            var afterStyles = this._afterStyles;\n\n            if (afterStyles) {\n              for (var _i3 = 0, _Object$entries2 = Object.entries(afterStyles); _i3 < _Object$entries2.length; _i3++) {\n                var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n                    key = _Object$entries2$_i[0],\n                    value = _Object$entries2$_i[1];\n\n                el.style.setProperty(key, value);\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\n\n  }, {\n    key: \"_willChange\",\n    value: function _willChange(addWillChange) {\n      var wc;\n      var effects = this._fxProperties;\n      var willChange;\n\n      if (addWillChange && effects) {\n        wc = [];\n\n        var _iterator23 = _createForOfIteratorHelper(effects),\n            _step23;\n\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var effect = _step23.value;\n            var propWC = effect.wc;\n\n            if (propWC === 'webkitTransform') {\n              wc.push('transform', '-webkit-transform');\n            } else if (propWC !== undefined) {\n              wc.push(propWC);\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n\n        willChange = wc.join(',');\n      } else {\n        willChange = '';\n      }\n\n      var elements = this._elements;\n\n      if (elements) {\n        var _iterator24 = _createForOfIteratorHelper(elements),\n            _step24;\n\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var el = _step24.value;\n            // ******** DOM WRITE ****************\n            el.style.setProperty('will-change', willChange);\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n    }\n    /**\r\n     * Start the animation with a user controlled progress.\r\n     */\n\n  }, {\n    key: \"progressStart\",\n    value: function progressStart() {\n      // ensure all past transition end events have been cleared\n      this._clearAsync(); // ******** DOM READ/WRITE ****************\n\n\n      this._beforeAnimation(); // ******** DOM WRITE ****************\n\n\n      this._progressStart();\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_progressStart\",\n    value: function _progressStart() {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator25 = _createForOfIteratorHelper(children),\n            _step25;\n\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var child = _step25.value;\n\n            // ******** DOM WRITE ****************\n            child._progressStart();\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n      } // force no duration, linear easing\n      // ******** DOM WRITE ****************\n\n\n      this._setTrans(0, true); // ******** DOM WRITE ****************\n\n\n      this._willChange(true);\n    }\n    /**\r\n     * Set the progress step for this animation.\r\n     * progressStep() is not debounced, so it should not be called faster than 60FPS.\r\n     */\n\n  }, {\n    key: \"progressStep\",\n    value: function progressStep(stepValue) {\n      // only update if the last update was more than 16ms ago\n      stepValue = Math.min(1, Math.max(0, stepValue));\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator26 = _createForOfIteratorHelper(children),\n            _step26;\n\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var child = _step26.value;\n            // ******** DOM WRITE ****************\n            child.progressStep(stepValue);\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n      } // ******** DOM WRITE ****************\n\n\n      this._progress(stepValue);\n    }\n    /**\r\n     * End the progress animation.\r\n     */\n\n  }, {\n    key: \"progressEnd\",\n    value: function progressEnd(shouldComplete, currentStepValue) {\n      var _this4 = this;\n\n      var dur = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      if (this._isReverse) {\n        // if the animation is going in reverse then\n        // flip the step value: 0 becomes 1, 1 becomes 0\n        currentStepValue = 1 - currentStepValue;\n      }\n\n      var stepValue = shouldComplete ? 1 : 0;\n      var diff = Math.abs(currentStepValue - stepValue);\n\n      if (dur < 0) {\n        dur = this._duration || 0;\n      } else if (diff < 0.05) {\n        dur = 0;\n      }\n\n      this._isAsync = dur > 30;\n\n      this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\n\n      if (this._isAsync) {\n        // for the root animation only\n        // set the async TRANSITION END event\n        // and run onFinishes when the transition ends\n        // ******** DOM WRITE ****************\n        this._asyncEnd(dur, shouldComplete); // this animation has a duration so we need another RAF\n        // for the CSS TRANSITION properties to kick in\n\n\n        if (!this._destroyed) {\n          raf(function () {\n            _this4._playToStep(stepValue);\n          });\n        }\n      }\n    }\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_progressEnd\",\n    value: function _progressEnd(shouldComplete, stepValue, dur, isAsync) {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator27 = _createForOfIteratorHelper(children),\n            _step27;\n\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var child = _step27.value;\n\n            // ******** DOM WRITE ****************\n            child._progressEnd(shouldComplete, stepValue, dur, isAsync);\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n      }\n\n      if (!isAsync) {\n        // stop immediately\n        // set all the animations to their final position\n        // ******** DOM WRITE ****************\n        this._progress(stepValue);\n\n        this._willChange(false);\n\n        this._setAfterStyles();\n\n        this._didFinish(shouldComplete);\n      } else {\n        // animate it back to it's ending position\n        this.isPlaying = true;\n        this.hasCompleted = false;\n        this._hasDur = true; // ******** DOM WRITE ****************\n\n        this._willChange(true);\n\n        this._setTrans(dur, false);\n      }\n    }\n    /**\r\n     * Add a callback to fire when the animation has finished.\r\n     */\n\n  }, {\n    key: \"onFinish\",\n    value: function onFinish(callback, opts) {\n      if (opts && opts.clearExistingCallbacks) {\n        this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\n      }\n\n      if (opts && opts.oneTimeCallback) {\n        this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\n\n        this._onFinishOneTimeCallbacks.push(callback);\n      } else {\n        this._onFinishCallbacks = this._onFinishCallbacks || [];\n\n        this._onFinishCallbacks.push(callback);\n      }\n\n      return this;\n    }\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\n\n  }, {\n    key: \"_didFinishAll\",\n    value: function _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator28 = _createForOfIteratorHelper(children),\n            _step28;\n\n        try {\n          for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n            var child = _step28.value;\n\n            child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\n          }\n        } catch (err) {\n          _iterator28.e(err);\n        } finally {\n          _iterator28.f();\n        }\n      }\n\n      if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\n        this._didFinish(hasCompleted);\n      }\n    }\n    /**\r\n     * NO RECURSION\r\n     */\n\n  }, {\n    key: \"_didFinish\",\n    value: function _didFinish(hasCompleted) {\n      this.isPlaying = false;\n      this.hasCompleted = hasCompleted;\n\n      if (this._onFinishCallbacks) {\n        // run all finish callbacks\n        var _iterator29 = _createForOfIteratorHelper(this._onFinishCallbacks),\n            _step29;\n\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var callback = _step29.value;\n            callback(this);\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      }\n\n      if (this._onFinishOneTimeCallbacks) {\n        // run all \"onetime\" finish callbacks\n        var _iterator30 = _createForOfIteratorHelper(this._onFinishOneTimeCallbacks),\n            _step30;\n\n        try {\n          for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n            var _callback = _step30.value;\n\n            _callback(this);\n          }\n        } catch (err) {\n          _iterator30.e(err);\n        } finally {\n          _iterator30.f();\n        }\n\n        this._onFinishOneTimeCallbacks.length = 0;\n      }\n    }\n    /**\r\n     * Reverse the animation.\r\n     */\n\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      var shouldReverse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator31 = _createForOfIteratorHelper(children),\n            _step31;\n\n        try {\n          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n            var child = _step31.value;\n            child.reverse(shouldReverse);\n          }\n        } catch (err) {\n          _iterator31.e(err);\n        } finally {\n          _iterator31.f();\n        }\n      }\n\n      this._isReverse = !!shouldReverse;\n      return this;\n    }\n    /**\r\n     * Recursively destroy this animation and all child animations.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._didFinish(false);\n\n      this._destroyed = true;\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator32 = _createForOfIteratorHelper(children),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var child = _step32.value;\n            child.destroy();\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n      }\n\n      this._clearAsync();\n\n      if (this._elements) {\n        this._elements.length = 0;\n      }\n\n      if (this._readCallbacks) {\n        this._readCallbacks.length = 0;\n      }\n\n      if (this._writeCallbacks) {\n        this._writeCallbacks.length = 0;\n      }\n\n      this.parent = undefined;\n\n      if (this._childAnimations) {\n        this._childAnimations.length = 0;\n      }\n\n      if (this._onFinishCallbacks) {\n        this._onFinishCallbacks.length = 0;\n      }\n\n      if (this._onFinishOneTimeCallbacks) {\n        this._onFinishOneTimeCallbacks.length = 0;\n      }\n    }\n    /**\r\n     * NO DOM\r\n     */\n\n  }, {\n    key: \"_transEl\",\n    value: function _transEl() {\n      // get the lowest level element that has an Animator\n      var children = this._childAnimations;\n\n      if (children) {\n        var _iterator33 = _createForOfIteratorHelper(children),\n            _step33;\n\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var child = _step33.value;\n\n            var targetEl = child._transEl();\n\n            if (targetEl) {\n              return targetEl;\n            }\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n      }\n\n      return this._hasTweenEffect && this._hasDur && this._elements !== undefined && this._elements.length > 0 ? this._elements[0] : null;\n    }\n  }]);\n\n  return Animator;\n}();\n\nvar create = function create(animationBuilder, baseEl, opts) {\n  if (animationBuilder) {\n    return animationBuilder(Animator, baseEl, opts);\n  }\n\n  return Promise.resolve(new Animator());\n};\n\nexport { create };","map":null,"metadata":{},"sourceType":"module"}